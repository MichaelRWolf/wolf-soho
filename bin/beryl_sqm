#!/usr/bin/env bash
# beryl_sqm: set SQM download/upload shaping rates on Beryl (OpenWrt) via SSH.
#
# Usage:
#   beryl_sqm --no-execute [args...]            # print ssh commands only (no changes)
#   beryl_sqm --dry-run [args...]               # alias for --no-execute (compat)
#   beryl_sqm [args...]                         # execute via ssh
#   beryl_sqm status                            # read-only: show settings + shaping
#   beryl_sqm day
#   beryl_sqm night
#   beryl_sqm <upload_kbit>                    # derives download from upload and recurses
#   beryl_sqm <download_kbit> <upload_kbit>    # set directly
#   beryl_sqm                                 # same as: beryl_sqm status
#
# Notes:
# - We treat a single numeric argument as *upload* (uplink) in kbit/s, because
#   uplink shaping is usually the primary "responsiveness" lever.
# - Derived download is controlled by BERYL_SQM_DL_PER_UL (default 7.75),
#   so upload=8000 -> download≈62000.
#
# Requirements:
# - SSH config entry for `beryl` (or set BERYL_HOST env var).
#
# NOTE: This script uses bash arrays. If invoked via `sh beryl_sqm` (or any
# non-bash shell), re-exec under bash so we don't trip `set -u` on bash-only
# expansions like "${argv[@]}".
#
# Must be POSIX-safe (no `[[ ... ]]`) because it may run under `/bin/sh`.
if [ -z "${BASH_VERSION:-}" ]; then
  exec bash "$0" "$@"
fi

set -euo pipefail

BERYL_HOST="${BERYL_HOST:-beryl}"
BERYL_SQM_SECTION="${BERYL_SQM_SECTION:-}"
BERYL_SQM_DL_PER_UL="${BERYL_SQM_DL_PER_UL:-7.75}"
NO_EXECUTE=0

die() {
  echo "ERROR: $*" >&2
  exit 2
}

is_int() {
  [[ "${1:-}" =~ ^[0-9]+$ ]]
}

ssh_on_beryl() {
  # Usage: ssh_on_beryl <command> [args...]
  #
  # In execute mode, runs:
  #   ssh root@beryl <command> [args...]
  #
  # In --no-execute mode, prints a pasteable command line using %q quoting.
  if [[ $NO_EXECUTE -eq 1 ]]; then
    printf 'ssh -o BatchMode=yes %q' "root@${BERYL_HOST}"
    local a
    for a in "$@"; do
      printf ' %q' "$a"
    done
    printf '\n'
    return 0
  fi

  ssh -o BatchMode=yes "root@${BERYL_HOST}" "$@"
}

derive_download_from_upload() {
  local upload_kbit="$1"
  # Round to nearest 1000 kbit/s to keep configs tidy.
  python3 - <<PY
import math
ul=int(${upload_kbit})
ratio=float("${BERYL_SQM_DL_PER_UL}")
dl=ul*ratio
dl_rounded=int(round(dl/1000.0)*1000)
print(dl_rounded)
PY
}

summary_down_up() {
  # Print a small, stable summary block based on kbit/s values.
  local dl="$1" ul="$2"

  case "$dl" in ''|*[!0-9]*) dl=0 ;; esac
  case "$ul" in ''|*[!0-9]*) ul=0 ;; esac

  local dl_pct_of_ul=0 ul_pct_of_dl=0
  if (( ul > 0 )); then
    dl_pct_of_ul=$(( dl * 100 / ul ))
  fi
  if (( dl > 0 )); then
    ul_pct_of_dl=$(( ul * 100 / dl ))
  fi

  printf "Download: %5s (%5s%% of upload)\n" "${dl}" "${dl_pct_of_ul}"
  printf "Upload:   %5s (%5s%% of download)\n"  "${ul}" "${ul_pct_of_dl}"
  if (( dl_pct_of_ul < 100 )); then
      printf "⚠️ WARNING: download less than upload\n"
  fi
}

detect_sqm_section() {
  # Returns the enabled SQM queue section name.
  #
  # NOTE: in --no-execute mode, we do not auto-detect (it requires remote reads).
  # Callers should handle an empty result by printing a helpful command to run.
  if [[ -n "${BERYL_SQM_SECTION}" ]]; then
    echo "${BERYL_SQM_SECTION}"
    return 0
  fi

  if [[ $NO_EXECUTE -eq 1 ]]; then
    echo ""
    return 0
  fi

  local sqm_show sections s en
  sqm_show="$(ssh_on_beryl uci show sqm 2>/dev/null || true)"
  sections="$(sed -n 's/^sqm\.\([^.]*\)=queue$/\1/p' <<<"$sqm_show")"
  for s in $sections; do
    en="$(ssh_on_beryl uci -q get "sqm.${s}.enabled" 2>/dev/null || true)"
    if [[ "$en" = "1" ]]; then
      echo "$s"
      return 0
    fi
  done
  return 1
}

print_no_execute_autodetect_help() {
  cat <<'EOF'
NOTE: --no-execute can’t auto-detect SQM_SECTION without running remote reads.

Run this to detect the enabled SQM section:
EOF

  # Print (not execute) a single ssh command that returns the enabled queue section.
  ssh_on_beryl sh -c '
sections="$(uci show sqm 2>/dev/null | sed -n '"'"'s/^sqm\.\([^.]*\)=queue$/\1/p'"'"')"
for s in $sections; do
  en="$(uci -q get "sqm.${s}.enabled" 2>/dev/null || true)"
  if [ "$en" = "1" ]; then
    echo "$s"
    exit 0
  fi
done
exit 1
'

  cat <<'EOF'

Then rerun with:
  BERYL_SQM_SECTION=<that_section> beryl_sqm --no-execute ...
EOF
}

do_show() {
  local sqm_section
  sqm_section="$(detect_sqm_section || true)"
  if [[ -z "$sqm_section" ]]; then
    if [[ $NO_EXECUTE -eq 1 ]]; then
      print_no_execute_autodetect_help
      return 0
    fi
    die "could not auto-detect an enabled SQM queue section"
  fi

  echo "=== SQM section ==="
  echo "$sqm_section"
  echo

  echo "=== SQM UCI config ==="
  ssh_on_beryl uci show "sqm.${sqm_section}" 2>/dev/null || true
  echo

  echo "=== Active qdiscs (eth0 + ifb4eth0 if present) ==="
  ssh_on_beryl tc -s qdisc show dev eth0 || true
  echo "---"
  ssh_on_beryl tc -s qdisc show dev ifb4eth0 || true
}

do_status() {
  local sqm_section
  sqm_section="$(detect_sqm_section || true)"
  if [[ -z "$sqm_section" ]]; then
    if [[ $NO_EXECUTE -eq 1 ]]; then
      print_no_execute_autodetect_help
      return 0
    fi
    die "could not auto-detect an enabled SQM queue section"
  fi

  echo "=== SQM section ==="
  echo "$sqm_section"
  echo

  local dl_kbit ul_kbit
  dl_kbit="$(ssh_on_beryl uci -q get "sqm.${sqm_section}.download" 2>/dev/null || echo 0)"
  ul_kbit="$(ssh_on_beryl uci -q get "sqm.${sqm_section}.upload" 2>/dev/null || echo 0)"

  echo "=== Speed Limits ==="
  summary_down_up "$dl_kbit" "$ul_kbit"
  echo

  echo "=== Shaping (ifb4eth0 / download, if present) ==="
  {
    local out
    out="$(ssh_on_beryl tc -s qdisc show dev ifb4eth0 2>/dev/null || true)"
    egrep '^(qdisc cake| Sent | backlog |  drops|  overlimits|  pk_delay|  av_delay)' <<<"$out" || true
  }
  echo

  echo "=== Shaping (eth0 / upload) ==="
  {
    local out
    out="$(ssh_on_beryl tc -s qdisc show dev eth0 2>/dev/null || true)"
    egrep '^(qdisc cake| Sent | backlog |  drops|  overlimits|  pk_delay|  av_delay)' <<<"$out" || true
  }
}

do_set() {
  local download_kbit="$1"
  local upload_kbit="$2"
  is_int "$download_kbit" || die "download must be integer kbit/s, got: $download_kbit"
  is_int "$upload_kbit" || die "upload must be integer kbit/s, got: $upload_kbit"

  local sqm_section
  sqm_section="$(detect_sqm_section || true)"
  if [[ -z "$sqm_section" ]]; then
    if [[ $NO_EXECUTE -eq 1 ]]; then
      print_no_execute_autodetect_help
      return 0
    fi
    die "could not auto-detect an enabled SQM queue section"
  fi

  echo "=== Setting SQM (download/upload) ==="
  echo "download_kbit=${download_kbit} upload_kbit=${upload_kbit}"
  echo

  ssh_on_beryl uci set "sqm.${sqm_section}.download=${download_kbit}"
  ssh_on_beryl uci set "sqm.${sqm_section}.upload=${upload_kbit}"
  ssh_on_beryl uci commit sqm
  ssh_on_beryl /etc/init.d/sqm restart
  echo

  echo "=== Applied SQM (download/upload) ==="
  local dl_kbit ul_kbit
  dl_kbit="$(ssh_on_beryl uci -q get "sqm.${sqm_section}.download" 2>/dev/null || echo 0)"
  ul_kbit="$(ssh_on_beryl uci -q get "sqm.${sqm_section}.upload" 2>/dev/null || echo 0)"
  echo "download_kbit=${dl_kbit} upload_kbit=${ul_kbit}"
  echo

  echo "=== Speed Limits ==="
  summary_down_up "$dl_kbit" "$ul_kbit"
  echo

  echo "=== Active qdiscs (eth0 + ifb4eth0 if present) ==="
  ssh_on_beryl tc -s qdisc show dev eth0 2>/dev/null | head -n 3 || true
  echo "---"
  ssh_on_beryl tc -s qdisc show dev ifb4eth0 2>/dev/null | head -n 3 || true
}

no_execute_args() {
  # Echo args to forward to recursive calls (only when NO_EXECUTE is enabled).
  if [[ $NO_EXECUTE -eq 1 ]]; then
    echo "--no-execute"
  fi
}

main() {
  local -a argv
  argv=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --no-execute|--dry-run|-n)
        NO_EXECUTE=1
        shift
        ;;
      --status)
        argv+=("status")
        shift
        ;;
      --help|-h)
        die "usage: beryl_sqm [--no-execute] [day|night|status|show|<upload_kbit>|<download_kbit> <upload_kbit>]"
        ;;
      *)
        argv+=("$1")
        shift
        ;;
    esac
  done
  # Bash 3.2 + `set -u` can error on expanding an empty array.
  if (( ${#argv[@]} )); then
    set -- "${argv[@]}"
  else
    set --
  fi

  if [[ $# -eq 0 ]]; then
    # No-arg invocation is read-only and should behave like `status`.
    do_status
    return 0
  fi

  if [[ $# -eq 1 ]]; then
    case "$1" in
      show)
        do_show
        return 0
        ;;
      status)
        do_status
        return 0
        ;;
      day)
        # Forward --no-execute only when enabled.
        main $(no_execute_args) 62000 8000
        return 0
        ;;
      night)
        main $(no_execute_args) 12000 8000
        return 0
        ;;
    esac

    local upload_kbit="$1"
    is_int "$upload_kbit" || die "1-arg form must be 'day', 'night', or <upload_kbit> (integer)"
    local download_kbit
    download_kbit="$(derive_download_from_upload "$upload_kbit")"
    echo "Derived download=${download_kbit} kbit/s from upload=${upload_kbit} kbit/s (BERYL_SQM_DL_PER_UL=${BERYL_SQM_DL_PER_UL})"
    echo
    main $(no_execute_args) "$download_kbit" "$upload_kbit"
    return 0
  fi

  if [[ $# -eq 2 ]]; then
    local download_kbit="$1"
    local upload_kbit="$2"

    # Warn early before doing any SSH / router-side changes.
    # (User can Ctrl-C here if this is a mistake.)
    if is_int "$download_kbit" && is_int "$upload_kbit" && 
        (( download_kbit < upload_kbit )); then
        echo "⚠️ WARNING: download ($download_kbit) is less than upload ($upload_kbit)" >&2
        sleep 2
    fi

    do_set "$download_kbit" "$upload_kbit"
    return 0
  fi

  die "usage: beryl_sqm [--no-execute] [day|night|status|show|<upload_kbit>|<download_kbit> <upload_kbit>]"
}

main "$@"

